\documentclass{article}

\usepackage{amsmath}
\usepackage{natbib}
\bibliographystyle{abbrvnat}

% These macros are borrowed from TAOCPMAC.tex
\newcommand{\slug}{\hbox{\kern1.5pt\vrule width2.5pt height6pt depth1.5pt\kern1.5pt}}
\def\xskip{\hskip 7pt plus 3pt minus 4pt}
\newdimen\algindent
\newif\ifitempar \itempartrue % normally true unless briefly set false
\def\algindentset#1{\setbox0\hbox{{\bf #1.\kern.25em}}\algindent=\wd0\relax}
\def\algbegin #1 #2{\algindentset{#21}\alg #1 #2} % when steps all have 1 digit
\def\aalgbegin #1 #2{\algindentset{#211}\alg #1 #2} % when 10 or more steps
\def\alg#1(#2). {\medbreak % Usage: \algbegin Algorithm A (algname). This...
  \noindent{\bf#1}({\it#2\/}).\xskip\ignorespaces}
\def\kalgstep#1.{\ifitempar\smallskip\noindent\else\itempartrue
   \hskip-\parindent\fi
   \hbox to\algindent{\bf\hfil #1.\kern.25em}%
   \hangindent=\algindent\hangafter=1\ignorespaces}

\newcommand{\algstep}[3]{\kalgstep #1 [#2] #3 }
\newenvironment{taocpalg}[3]{%
\vspace{1em}%
\algbegin Algorithm #1. ({#2}). #3 }
{\vspace{1em}}


\DeclareMathOperator*{\npOnes}{Ones}
\DeclareMathOperator*{\npZeros}{Zeros}
\DeclareMathOperator*{\argmax}{argmax}

\begin{document}

\begin{abstract}
The Li and Stephens model is one of the key techiques underpinning modern
genomics. The ability to solve the model exactly for large number of
sites has made it very attractive. But it scales linearly in the number
of samples, which is now far too slow. People are using approximations
to address this. We introduce an algorithm that uses the succinct
tree sequence structure that solves the Li and Stephens model exactly
in logarithmic time (under certain assumptions about the structure
of the trees). We show how this algorithm out-performs existing implementations
and enables applications in the soon-to-be available megasample data sets.

\end{abstract}


\section{Introduction}

\begin{itemize}
\item Very large datasets.
\item Li and Stephens~\citep{li2003modeling} is important. Cite Donnely and
Leslie. Lots of applications.
\item Much recent interest. Method improving performance with BWT~\citep{lunter2018haplotype}
and also \citep{rosen2018average}.
\item Tree sequences.
\citep{kelleher2016efficient,kelleher2018efficient,kelleher2018inferring,haller2018tree}.
\item Paper roadmap.
\end{itemize}

\section{Li and Stephens model}

\begin{itemize}
\item Description of the LS model with diagram based on the variant matrix.
\item Viterbi algorithm listing using variant matrix.
\item Quick algorithm analysis.
\item Possibly forward/backward also?
\end{itemize}


\clearpage

\begin{taocpalg}{M}{Matrix based Li and Stephens Viterbi algorithm.
Given a haplotype of $h$ of length $m$ and a reference panel $H$
of $n$ haplotypes, return a path $P$ with maximum probability given
the scaled recombination and mutation rates, $\rho$ and $\theta$.}

\algstep{M1.}{Initialisation.}{
Set $V \leftarrow \npOnes(n)$, $T \leftarrow \npZeros(n, m)$
and $\ell \leftarrow 0$. }

\algstep{M2.}{Normalise.}{
Set $k \leftarrow \argmax(V)$ and $V \leftarrow V / V_k$. Then set
$V' \leftarrow \npZeros(n)$ and $j \leftarrow 0$.}

\algstep{M3.}{Recombination.}{
Set $x \leftarrow \mbox{P recomb} V_j$ and $y \leftarrow \mbox{P no recomb}$.
Then, if $x > y$ set $p_{max} \leftarrow x$ and $T_{j, l} \leftarrow j$;
otherwise, set $p_{max} \leftarrow y$ and $T_{j, l} \leftarrow k_{max}$.
}

\algstep{M4.}{Emission.}{
Set $p_{emiss} \leftarrow $ (finish).
}

\algstep{M5.}{Haplotype loop.}{
Set $V'_{j} \leftarrow p_{max} p_{emiss}$ and $j \leftarrow j + 1$. Then,
if $j < n$ go to step M3.
}

\algstep{M6.}{Site loop.}{
Set $V \leftarrow V'_{j}$ and $\ell \leftarrow \ell + 1$. Then,
if $\ell < m$ go to step M2.
}

\algstep{M7.}{Traceback.}{
Set $P\leftarrow \npZeros(m)$, $\ell \leftarrow m - 1$ and $P_\ell \leftarrow
\argmax(V)$. Then, while $l > 1$ set $P_{l - 1} \leftarrow T_{P_ell, \ell}$
and $\ell \leftarrow \ell - 1$.
}

\end{taocpalg}


\section{Tree sequence algorithm}

\begin{itemize}
\item Brief description of the tree sequence basics. Nodes, edges, etc.
\item Viterbi algorithm listing using tree sequences.
\item Algorithm analysis.
\end{itemize}

\section{Performance}

\begin{itemize}
\item Comparison of LS algorithm implementations.
\end{itemize}


\section{Discussion}

\bibliography{references}

\end{document}
