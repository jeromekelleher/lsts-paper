\documentclass{article}

\usepackage{amsmath}
\usepackage{natbib}
\bibliographystyle{abbrvnat}

% These macros are borrowed from TAOCPMAC.tex
\newcommand{\slug}{\hbox{\kern1.5pt\vrule width2.5pt height6pt depth1.5pt\kern1.5pt}}
\def\xskip{\hskip 7pt plus 3pt minus 4pt}
\newdimen\algindent
\newif\ifitempar \itempartrue % normally true unless briefly set false
\def\algindentset#1{\setbox0\hbox{{\bf #1.\kern.25em}}\algindent=\wd0\relax}
\def\algbegin #1 #2{\algindentset{#21}\alg #1 #2} % when steps all have 1 digit
\def\aalgbegin #1 #2{\algindentset{#211}\alg #1 #2} % when 10 or more steps
\def\alg#1(#2). {\medbreak % Usage: \algbegin Algorithm A (algname). This...
  \noindent{\bf#1}({\it#2\/}).\xskip\ignorespaces}
\def\kalgstep#1.{\ifitempar\smallskip\noindent\else\itempartrue
   \hskip-\parindent\fi
   \hbox to\algindent{\bf\hfil #1.\kern.25em}%
   \hangindent=\algindent\hangafter=1\ignorespaces}

\newcommand{\algstep}[3]{\kalgstep #1 [#2] #3 }
\newenvironment{taocpalg}[3]{%
\vspace{1em}%
\algbegin Algorithm #1. ({#2}). #3 }
{\vspace{1em}}


\DeclareMathOperator*{\npOnes}{Ones}
\DeclareMathOperator*{\npZeros}{Zeros}
\DeclareMathOperator*{\argmax}{argmax}

\begin{document}

\begin{abstract}
The Li and Stephens model is one of the key techiques underpinning modern
genomics. The ability to solve the model exactly for large number of
sites has made it very attractive. But it scales linearly in the number
of samples, which is now far too slow. People are using approximations
to address this. We introduce an algorithm that uses the succinct
tree sequence structure that solves the Li and Stephens model exactly
in logarithmic time (under certain assumptions about the structure
of the trees). We show how this algorithm out-performs existing implementations
and enables applications in the soon-to-be available megasample data sets.

\end{abstract}


\section{Introduction}

\begin{itemize}
\item Very large datasets.
\item Li and Stephens~\citep{li2003modeling,donnelly2010coalescent} is important. Cite Donnely and
Leslie. Lots of applications.
\item Much recent interest. Method improving performance with BWT~\citep{lunter2018haplotype}
and also \citep{rosen2018average}.
\item Tree sequences.
\citep{kelleher2016efficient,kelleher2018efficient,kelleher2018inferring,haller2018tree}.
\item Paper roadmap.
\end{itemize}

\section{Li and Stephens model}

\begin{itemize}
\item Description of the LS model with diagram based on the variant matrix.
\item Viterbi algorithm listing using variant matrix.
\item Quick algorithm analysis.
\item Possibly forward/backward also?
\end{itemize}

The transition probability is given by
\[
Q(j, k, \ell) = \begin{cases}
1 - r_\ell + r_\ell / n & \text{if $j = k$} \\
r_\ell / n & \text{otherwise}
\end{cases}
\]
where $Q(j, k, \ell)$ is the probability of transition from haplotype $j$
to haplotype $k$ at locus $\ell$, and $r_\ell$ is the recombination `weight'
between site $\ell$ and $\ell - 1$. [Is this the right way around? Work out
the corner case at 0/m.]


[Note: there are different ways in which we can calibrate the mutation and
recombination weights. Need to discuss this and put some bounds on what
the weights really mean and how they interplay between mutation and
recombination.]

The emission probability is given by
\[
E(j, \ell) = \begin{cases}
1 - \mu_\ell / (a_\ell - 1)  & \text{if $H_{j, \ell} = h_{\ell}$} \\
\mu_\ell & \text{otherwise}
\end{cases}
\]
where $\mu_\ell$ is the probability of mutatating from one of the
$a_\ell$ alleles to a different allele at site $\ell$.

\clearpage

\begin{taocpalg}{M}{Matrix based Li and Stephens Viterbi algorithm.
Given a haplotype of $h$ of length $m$ and a reference panel $H$
of $n$ haplotypes, return a path $P$ with maximum probability given
the recombination and mutation weights, $\rho$ and $\theta$.}

\algstep{M1.}{Initialisation.}{
Set $V \leftarrow \npOnes(n)$, $T \leftarrow \npZeros(n, m)$
and $\ell \leftarrow 0$. }

\algstep{M2.}{Normalise.}{
Set $i \leftarrow \argmax(V)$ and $V \leftarrow V / V_i$. Then set
$V' \leftarrow \npZeros(n)$ and $j \leftarrow 0$.}

\algstep{M3.}{Recombination.}{
Set $x \leftarrow V_j \rho_\ell / n$ and $y \leftarrow 1 - \rho_\ell + \rho_\ell / n$.
Then, if $x > y$ set $p_t \leftarrow x$ and $T_{j, l} \leftarrow j$;
otherwise, set $p_t \leftarrow y$ and $T_{j, l} \leftarrow i$.
}

\algstep{M4.}{Emission.}{
If $H_{j, \ell} = h_\ell$ set $p_e \leftarrow 1 - (a_\ell - 1)\mu_\ell$;
otherwise, set $p_e \leftarrow \mu_\ell$.
}

\algstep{M5.}{Haplotype loop.}{
Set $V'_{j} \leftarrow p_{t} p_{e}$ and $j \leftarrow j + 1$. Then,
if $j < n$ go to step M3.
}

\algstep{M6.}{Site loop.}{
Set $V \leftarrow V'_{j}$ and $\ell \leftarrow \ell + 1$. Then,
if $\ell < m$ go to step M2.
}

\algstep{M7.}{Traceback.}{
Set $P\leftarrow \npZeros(m)$, $\ell \leftarrow m - 1$ and $P_\ell \leftarrow
\argmax(V)$. Then, while $l > 1$ set $P_{l - 1} \leftarrow T_{P_\ell, \ell}$
and $\ell \leftarrow \ell - 1$.
}

\end{taocpalg}


\section{Tree sequence algorithm}

\begin{itemize}
\item Brief description of the tree sequence basics. Nodes, edges, etc.
\item Viterbi algorithm listing using tree sequences.
\item Algorithm analysis.
\end{itemize}

\section{Performance}

\begin{itemize}
\item Comparison of LS algorithm implementations.
\end{itemize}


\section{Discussion}

\bibliography{references}

\end{document}
